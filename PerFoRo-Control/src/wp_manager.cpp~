#include "wp_manager.h"

/**
 * Waypoint Manager
*/

WaypointManager::WaypointManager() :
	_n(),
	_sub(_n.subscribe("iris/vehicle_local_position_setpoint", 1000, &WaypointManager::pos_spCallback,this)),
	_waypoints_pub(_n.advertise<wpm::waypoints>("mission", 10,true))
{
	
}	


void WaypointManager::pos_spCallback(const px4::vehicle_local_position_setpoint msg)
{
  ROS_INFO("Waypoint Manager: I heard: [%f]", msg.z);
}

void WaypointManager::set_waypoints(double waypoints[][NO_OF_COLUMNS], int no_of_waypoints, int current_waypoint)
{
	if ( no_of_waypoints <= MAX_WAYPOINTS ) {
		clear_all_waypoints();
		std::vector<double> wp;
		for(int row = 0 ; row < no_of_waypoints ; row++)
		{
			wps.WP.push_back(wp);
			for(int column = 0 ; column < NO_OF_COLUMNS ; column++)
			{
				wps.WP[row].push_back(waypoints[row][column]);
			}	
		}
		ROS_INFO("Waypoint Manager: Set Waypoints");
		if (current_waypoint <= wps.WP.size()) {
			wps.current_waypoint = current_waypoint;
			ROS_INFO("Waypoint Manager: Set current waypoint %d", current_waypoint);
		} else {
			ROS_INFO("Waypoint Manager: Set Current Waypoint Out of bound, Available waypoints = %d", wps.no_of_waypoints);			
		}
		sync_waypoints();
	} else {
		ROS_INFO("Waypoint Manager: Waypoints exceed MAX WAYPOINTS (i.e >%d)", MAX_WAYPOINTS);
	}
			
}

void WaypointManager::add_waypoint(double waypoint[1][NO_OF_COLUMNS], int position)
{
	if ( position <= wps.no_of_waypoints + 1 && wps.no_of_waypoints < MAX_WAYPOINTS) {
		std::vector<double> wp;
		for ( int column = 0; column < NO_OF_COLUMNS; column++ ) {
			wp.push_back(waypoint[0][column]);
		}
		i = wps.WP.begin();
		wps.WP.insert(i + position - 1, wp);
		ROS_INFO("Waypoint Manager: Added waypoint at position %d", position);
		sync_waypoints();
	} else {
		ROS_INFO("Waypoint Manager: Waypoint to add not in sequence OR Waypoints exceed MAX WAYPOINTS (i.e > %d)", MAX_WAYPOINTS);
	}	
}

void WaypointManager::clear_all_waypoints()
{	
	int no_of_waypoints = wps.no_of_waypoints;
	if ( no_of_waypoints > 0) {
		//i = wps.WP.begin();
		//wps.WP.erase(i, i + no_of_waypoints);
		wps.WP.clear();
		ROS_INFO("Waypoint Manager: Erased all waypoints");
		sync_waypoints();
	}	
}

void WaypointManager::clear_waypoint(int waypoint_no)
{
	if (waypoint_no <= wps.no_of_waypoints) {
		i = wps.WP.begin();
		wps.WP.erase(i + waypoint_no - 1);
		ROS_INFO("Waypoint Manager: Erased waypoint %d", waypoint_no);
		sync_waypoints();	
	} else {
		ROS_INFO("Waypoint Manager: Clear Waypoint Out of bound, Available waypoints = %d", wps.no_of_waypoints);
	}
}

void WaypointManager::set_current_waypoint(int waypoint_no)
{
	if (waypoint_no <= wps.no_of_waypoints) {
		wps.current_waypoint = waypoint_no;
		sync_waypoints();
		ROS_INFO("Waypoint Manager: Set current waypoint %d", waypoint_no);
	} else {
		ROS_INFO("Waypoint Manager: Set Current Waypoint Out of bound, Available waypoints = %d", wps.no_of_waypoints);
		//wps.current_waypoint = wps.default_current_waypoint;
		//ROS_INFO("Waypoint Manager: Default Current waypoint set to %d", wps.default_current_waypoint);
	}		
}

void WaypointManager::sync_waypoints()
{
	wps.no_of_waypoints = wps.WP.size();
	wpm::single_waypoint _single_waypoint_msg;
	wpm::waypoints _waypoints_msg;
	if ( wps.no_of_waypoints > 0 ) {
		
		for ( int row = 0; row < wps.no_of_waypoints; row++) {
		_single_waypoint_msg.wp = wps.WP.at(row);
		_waypoints_msg.WP.push_back(_single_waypoint_msg);
		}
	} else if ( wps.no_of_waypoints == 0 ) {
		_waypoints_msg.WP.clear();
		_single_waypoint_msg.wp.clear();
		wpm_init();
	}
	_waypoints_msg.no_of_waypoints = wps.no_of_waypoints;
	_waypoints_msg.current_waypoint = wps.current_waypoint;
	_waypoints_pub.publish(_waypoints_msg);
	/*
	for(int row=0 ; row<wps.no_of_waypoints ; row++)
	{
		for(int column=0 ; column< NO_OF_COLUMNS ; column++)
		{
			wps.waypoints[row][column] = wps.WP[row].at(column);	
		}	
	}*/
}

void WaypointManager::print()
{
	int no_of_waypoints = wps.no_of_waypoints;
	for(int rows = 0 ; rows < no_of_waypoints ; rows++)
	{
		for(int columns = 0 ; columns < NO_OF_COLUMNS ; columns++)
		{
		    printf("%f\t",wps.WP[rows].at(columns));
		}
		printf("\n");	
	}
	std::cout<<"No of Waypoints = "<<no_of_waypoints<<std::endl;
	std::cout<<"Current Waypoint = "<<wps.current_waypoint<<std::endl;
	//ROS_INFO("%d\t%d\t%d\n%d\t%d\t%d", wps.WP[0].at(0), wps.WP[0].at(1), wps.WP[0].at(2), wps.WP[1].at(0), wps.WP[1].at(1), wps.WP[1].at(2));
}

void WaypointManager::wpm_init()
{
	wps.no_of_waypoints = 0;
	wps.current_waypoint = 1;
	//wps.default_current_waypoint = 1;
}

int main(int argc, char **argv)
{
	/**
	* The ros::init() function needs to see argc and argv so that it can perform
	* any ROS arguments and name remapping that were provided at the command line. For programmatic
	* remappings you can use a different version of init() which takes remappings
	* directly, but for most command-line programs, passing argc and argv is the easiest
	* way to do it.  The third argument to init() is the name of the node.
	*
	* You must call one of the versions of ros::init() before using any other
	* part of the ROS system.
	*/
	ros::init(argc, argv, "waypoint_manager");

	WaypointManager WPM;
	WPM.wpm_init();
	
	double waypoints[5][NO_OF_COLUMNS] = { {1,2,3,0.01,0,0,0,5,0} , {4,5,6,0.05,0,0,10,5,0} , {7,8,9,0.10,0,0,1,5,0} , {10,11,12,0.3,0,0,0,5,0} , {13,14,15,-0.01,0,0,0,5,0} };
	double waypoint[1][NO_OF_COLUMNS] = { {16,17,18,0.5,0,0,0,5,0} };
	WPM.set_waypoints(waypoints,sizeof(waypoints)/sizeof(*waypoints),1);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.clear_waypoint(1);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.clear_waypoint(3);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.clear_all_waypoints();
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.set_waypoints(waypoints,sizeof(waypoints)/sizeof(*waypoints),5);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.add_waypoint(waypoint,3);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.set_current_waypoint(4);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.set_current_waypoint(10);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.add_waypoint(waypoint,8);
	//WPM.print();
	ros::Duration(5).sleep();
	WPM.clear_waypoint(8);
	//WPM.print();
	/**
	* ros::spin() will enter a loop, pumping callbacks.  With this version, all
	* callbacks will be called from within this thread (the main one).  ros::spin()
	* will exit when Ctrl-C is pressed, or the node is shutdown by the master.
	*/
	ros::spin();
	
	return 0;
}
